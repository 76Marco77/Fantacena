Name: Update Gist (Serie A) ‚Äî Rescue Mode

on:
  schedule:
    # Venerd√¨
    - cron: "*/15 16-23 * * 5"
    # Sabato
    - cron: "*/15 13-23 * 4-10 6"
    - cron: "*/15 14-23 * 11,12,1,2,3 6"
    # Luned√¨
    - cron: "*/15 16-23 * * 1"
    # Domenica
    - cron: "30,45 10 * * 0"
    - cron: "0,15,30,45 11-21 * * 0"
    - cron: "0,15,30 22 * * 0"
    - cron: "*/15 23 * * 0"

  workflow_dispatch:
    inputs:
      upcoming_order:
        description: "Ordine partite future: asc = dalla pi√π prossima; desc = dalla pi√π lontana"
        required: false
        default: asc
        type: choice
        options: [asc, desc]

permissions: {}

# CAMBIATO IL NOME DEL GRUPPO PER SBLOCCARE LA CODA
concurrency:
  group: update-serie-a-rescue
  cancel-in-progress: true

jobs:
  sync:
    # USIAMO UNA VERSIONE SPECIFICA DI UBUNTU MENO AFFOLLATA
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    env:
      TZ: Europe/Rome
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check secrets
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "‚ùå Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "‚ùå Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "‚ùå Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "‚úÖ Secrets OK"

      - name: Build & push Gist (Rescue Mode)
        env:
          GIST_ID:          ${{ secrets.GIST_ID }}
          GIST_TOKEN:       ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:         ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE:        Classifica.json
          UPCOMING_ORDER:   ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.upcoming_order || vars.UPCOMING_ORDER || 'asc' }}
          GITHUB_RUN_ID:       ${{ github.run_id }}
        run: |
          node - <<'NODE'
          const FD='https://api.football-data.org/v4', COMP='SA', TZ='Europe/Rome';
          const HEAD_FD={'X-Auth-Token':process.env.FD_TOKEN,'Accept':'application/json','User-Agent':'fantacena-rescue'};
          const HEAD_GH={'authorization':`token ${process.env.GIST_TOKEN}`,'accept':'application/vnd.github+json','user-agent':'seriea-rescue'};
          
          const fmtLocal=new Intl.DateTimeFormat('it-IT',{dateStyle:'full',timeStyle:'long',timeZone:TZ});
          console.log('‚è±Ô∏è Local:', fmtLocal.format(new Date()), '| UTC:', new Date().toISOString());
          
          const ORDER = (String(process.env.UPCOMING_ORDER||'asc').toLowerCase()==='desc') ? 'desc' : 'asc';
          
          const cmpUpcoming=(a,b)=>{
            const ta=Date.parse(a.start||''); const tb=Date.parse(b.start||'');
            if (ta!==tb) return ta - tb;
            const ah=(a.home||'').toLowerCase(), aw=(a.away||'').toLowerCase();
            const bh=(b.home||'').toLowerCase(), bw=(b.away||'').toLowerCase();
            return (ah+aw).localeCompare(bh+bw);
          };

          const sleep=ms=>new Promise(r=>setTimeout(r,ms));
          
          async function fetchRetry(u,opt={}, {tries=4,base=500}={}){
            for(let i=0;;i++){
              try {
                const r=await fetch(u,opt);
                if(r.ok) return r;
                
                // Gestione 429
                if(r.status === 429) {
                   console.log(`‚ö†Ô∏è Rate Limit hit (429) su ${u}. Pause...`);
                   await sleep(2500 * (i+1));
                   if(i<tries) continue;
                }

                if(![500,502,503,504].includes(r.status) || i>=tries-1){
                  const t=await r.text().catch(()=> ''); 
                  throw new Error(`${opt.method||'GET'} ${r.status} ${u} ${t.slice(0,300).replace(/\s+/g,' ')}`);
                }
                
                console.log(`‚ö†Ô∏è Retry ${i+1}/${tries} per ${u} (Status: ${r.status})`);
                await sleep(Math.round(base*Math.pow(2,i)));
              } catch (e) {
                if(i>=tries-1) throw e;
                console.log(`‚ö†Ô∏è Network Err Retry ${i+1}/${tries}: ${e.message}`);
                await sleep(Math.round(base*Math.pow(2,i)));
              }
            }
          }

          async function httpFD(u){ const r=await fetchRetry(u,{headers:HEAD_FD}); return r.json(); }
          async function gh(u,opt={}){ return fetchRetry(u,{...opt,headers:{...HEAD_GH,...(opt.headers||{})}}); }

          async function readCurrent(){
            try {
                const r=await gh(`https://api.github.com/gists/${process.env.GIST_ID}`);
                const j=await r.json(); const f=j.files?.[process.env.GIST_FILE||'Classifica.json'];
                return f&&f.content?JSON.parse(f.content):{}; 
            } catch(e) { 
                console.warn("‚ö†Ô∏è Impossibile leggere Gist corrente:", e.message);
                return {}; 
            }
          }

          async function writeGist(payload){
            const body={files:{[process.env.GIST_FILE||'Classifica.json']:{content:JSON.stringify(payload,null,2)}}};
            const url=`https://api.github.com/gists/${process.env.GIST_ID}`;
            const r=await gh(url,{method:'PATCH',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
            if(!r.ok){ const txt=await r.text().catch(()=> ''); throw new Error(`PATCH ${r.status} ${url} ${txt.slice(0,300).replace(/\s+/g,' ')}`); }
          }

          const norm=s=>String(s||'').replace(/\s+/g,' ').trim();
          const rank=s=>s==='in'?3:s==='post'?2:s==='pre'?1:0;

          async function fetchStandings(){
            const j=await httpFD(`${FD}/competitions/${COMP}/standings`);
            const t=j.standings?.find(s=>/TOTAL/i.test(s.type))?.table||[];
            return {
              teams:   t.map(r=>norm(r.team?.shortName||r.team?.name||r.team?.tla)),
              pos_real:t.map((_,i)=>i+1),
              played:  t.map(r=>r.playedGames ?? null),
              points:  t.map(r=>r.points ?? null)
            };
          }

          async function fetchMatches3Days(){
            const now=new Date(), cutoff=new Date(now.getTime()-72*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            const j=await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(cutoff)}&dateTo=${dstr(now)}`);
            const rows=(j.matches||[]).map(m=>({
              home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
              away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
              sh:m.score?.fullTime?.home ?? m.score?.halfTime?.home ?? null,
              sa:m.score?.fullTime?.away ?? m.score?.halfTime?.away ?? null,
              status:/FINISHED|IN_PLAY|PAUSED/.test(m.status)?(m.status==='FINISHED'?'post':'in'):'pre',
              start:m.utcDate||null
            }));
            const latest=new Map();
            for(const r of rows){
              const k=`${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const p=latest.get(k); if(!p || rank(r.status)>rank(p.status)) latest.set(k,r);
            }
            return Array.from(latest.values()).filter(r=>{
              if(!r.start) return false; const dt=new Date(r.start);
              return dt>=cutoff && dt<=now;
            }).sort((a,b)=>String(a.start).localeCompare(String(b.start)));
          }

          async function fetchUpcomingNext5Days(){
            const now=new Date(), end=new Date(now.getTime()+5*24*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            
            console.log(`üîç [Upcoming] Requesting range: ${dstr(now)} -> ${dstr(end)}`);
            let j=await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED&dateFrom=${dstr(now)}&dateTo=${dstr(end)}`);
            
            // üõ°Ô∏è PROTEZIONE: Ritorna array vuoto se 0 match trovati, niente fallback "All Season"
            if(!j.matches?.length){ 
                console.log("‚ÑπÔ∏è API returned 0 scheduled matches. Accepting.");
                return []; 
            }

            const BAD=new Set(['POSTPONED','CANCELED','SUSPENDED','AWARDED']);
            let rows=(j.matches||[])
              .filter(m=>!BAD.has(String(m.status||'').toUpperCase()))
              .map(m=>({
                home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
                away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
                sh:null, sa:null, status:'pre',
                start:m.utcDate||null
              }))
              .filter(r=>{ const t=Date.parse(r.start||''); return Number.isFinite(t)&&t>=now.getTime()&&t<=end.getTime(); })
              .sort(cmpUpcoming);
            
            if(ORDER==='desc') rows=rows.reverse();
            
            const seen=new Set(), out=[];
            for(const r of rows){ const k=`${r.home}|${r.away}|${r.start||""}`; if(!seen.has(k)){ seen.add(k); out.push(r); } }
            
            console.log(`‚úÖ [Upcoming] Found ${out.length} matches.`);
            return out;
          }

          (async()=>{
            try {
                const current=await readCurrent();
                
                // Wrapper sicuro
                const safeFetch = (p, name) => p.catch(e => { console.error(`‚ùå ${name} failed:`, e.message); return null; });

                const [st, past72, next] = await Promise.all([
                    safeFetch(fetchStandings(), 'Standings'),
                    safeFetch(fetchMatches3Days(), 'PastMatches'),
                    safeFetch(fetchUpcomingNext5Days(), 'UpcomingMatches')
                ]);

                if(!st) throw new Error("Critical: Standings API failed.");

                const validPast = past72 || [];
                const validNext = next || [];

                const key=r=>`${r.home}|${r.away}|${r.start||""}`;
                const map=new Map();
                for(const r of [...validPast, ...validNext]){ if(r && r.home && r.away) map.set(key(r), r); }
                const results_raw=[...map.values()];
                const now=new Date();
                
                const payload={
                  ...current,
                  teams:st.teams, pos_real:st.pos_real, played:st.played, points:st.points,
                  results_raw,
                  upcoming_raw: validNext,
                  counts:{
                    pre: results_raw.filter(r=>r.status==='pre').length,
                    in:  results_raw.filter(r=>r.status==='in').length,
                    post:results_raw.filter(r=>r.status==='post').length
                  },
                  synced_at: now.toISOString(),
                  _meta:{
                    timezone: TZ,
                    order_upcoming: ORDER,
                    now_utc: now.toISOString(),
                    run_id: process.env.GITHUB_RUN_ID || null,
                  }
                };
                
                await writeGist(payload);
                console.log(`‚úÖ Gist SUCCESS | Next: ${validNext.length} | Past: ${validPast.length}`);
            } catch(e) {
                console.error('‚ùå FATAL MAIN:', e.stack||e.message);
                process.exit(1);
            }
          })();
          NODE


