
name: Update Gist (Serie A) — clean dedup final (manual scorers, 72h + next24h)

on:
  schedule:
    - cron: "0 16-23 * * 5,6,1"
    - cron: "30 10-22 * * 0"
    - cron: "0 22-23 * * 0"
  workflow_dispatch:
    inputs:
      force:
        description: "Esegui subito (ignora guard: 23:00 Europe/Rome)"
        required: false
        default: "false"

permissions: {}
concurrency:
  group: update-serie-a-gist
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    env:
      TZ: Europe/Rome
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with: { node-version: '20' }

      - name: Check secrets
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "❌ Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "❌ Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "❌ Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "::add-mask::$GIST_TOKEN"
          echo "::add-mask::$FD_TOKEN"
          echo "✅ Secrets OK"

      - name: Build & push Gist (72h results + next24h fixtures)
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE:  Classifica.json
          FORCE_RUN:  ${{ github.event.inputs.force }}
        run: |
          node - <<'NODE'
          const FD  = 'https://api.football-data.org/v4';
          const COMP = 'SA';
          const TZ  = 'Europe/Rome';

          const HEAD_FD = {
            'X-Auth-Token': process.env.FD_TOKEN,
            'Accept': 'application/json',
            'User-Agent': 'fantacena-updater'
          };
          const HEAD_GH = {
            'authorization': `Bearer ${process.env.GIST_TOKEN}`,
            'accept': 'application/vnd.github+json',
            'user-agent': 'seriea-fd-only'
          };

          const sleep = ms => new Promise(r => setTimeout(r, ms));
          async function fetchRetry(url, opt = {}, { tries = 5, base = 400 } = {}) {
            let n = 0;
            while (true) {
              n++;
              const r = await fetch(url, opt);
              if (r.ok) return r;
              const retryable = [429,500,502,503,504].includes(r.status);
              if (!retryable || n >= tries) {
                const t = await r.text().catch(()=> '');
                throw new Error(`${opt.method||'GET'} ${r.status} ${url} ${t}`);
              }
              const wait = Math.round(base * 2**(n-1));
              console.log(`↻ Retry ${n}/${tries} in ${wait}ms: ${url} (${r.status})`);
              await sleep(wait);
            }
          }
          async function httpFD(u){ const r = await fetchRetry(u,{headers:HEAD_FD}); return r.json(); }
          async function gh(u,opt={}){ return fetchRetry(u,{...opt,headers:{...HEAD_GH,...(opt.headers||{})}}); }

          (function guard(){
            const force = String(process.env.FORCE_RUN||'false').toLowerCase()==='true';
            if (force) { console.log('⚠️ FORCE_RUN=true'); return; }
            const now = new Date();
            const fmt = ops => new Intl.DateTimeFormat('en-GB',{ timeZone:TZ, ...ops });
            const wd  = fmt({ weekday:'short' }).format(now);
            const hr  = Number(fmt({ hour:'2-digit', hour12:false }).format(now));
            const min = Number(fmt({ minute:'2-digit' }).format(now));
            const inRange = (a,b)=> hr>=a && hr<=b;
            const at = (h,m)=> hr===h && min===m;
            const isFSM_hours    = (['Fri','Sat','Mon'].includes(wd) && min===0 && inRange(18,23));
            const isFSM_midnight = ((wd==='Sat'||wd==='Sun'||wd==='Tue') && at(0,0));
            const isSun30        = (wd==='Sun' && min===30 && inRange(12,23));
            const isSunMid       = (wd==='Mon' && at(0,0));
            const allowed = isFSM_hours || isFSM_midnight || isSun30 || isSunMid;
            if (!allowed) {
              console.log(`⏭️ Outside allowed window ${TZ}: ${wd} ${String(hr).padStart(2,'0')}:${String(min).padStart(2,'0')}`);
              process.exit(0);
            }
          })();

          async function readCurrent(){
            const j = await (await gh(`https://api.github.com/gists/${process.env.GIST_ID}`)).json();
            const f = j.files?.[process.env.GIST_FILE||'Classifica.json'];
            try { return f && f.content ? JSON.parse(f.content) : {}; } catch { return {}; }
          }
          async function writeGist(payload){
            const body = { files: { [process.env.GIST_FILE||'Classifica.json']: { content: JSON.stringify(payload,null,2) } } };
            await gh(`https://api.github.com/gists/${process.env.GIST_ID}`, { method:'PATCH', headers:{'content-type':'application/json'}, body: JSON.stringify(body) });
          }

          const norm = s => String(s||'').replace(/\s+/g,' ').trim();
          const rank = s => s==='in' ? 3 : s==='post' ? 2 : s==='pre' ? 1 : 0;

          function ymdTZ(d, tz){
            const p = new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'}).formatToParts(d);
            const get = t => p.find(x=>x.type===t)?.value;
            return `${get('year')}-${get('month')}-${get('day')}`;
          }
          function hmTZ(d, tz){
            const p = new Intl.DateTimeFormat('it-IT',{timeZone:tz,hour:'2-digit',minute:'2-digit',hour12:false}).formatToParts(d);
            const g = t => p.find(x=>x.type===t)?.value;
            return `${g('hour')}:${g('minute')}`;
          }

          async function fetchStandings(){
            const j = await httpFD(`${FD}/competitions/${COMP}/standings`);
            const t = j.standings?.find(s=>/TOTAL/i.test(s.type))?.table || [];
            return {
              teams:   t.map(r => norm(r.team?.shortName || r.team?.name || r.team?.tla)),
              pos_real:t.map((_,i)=>i+1),
              played:  t.map(r => r.playedGames ?? null),
              points:  t.map(r => r.points ?? null),
            };
          }

          async function fetchMatches3Days(){
            const now = new Date();
            const cutoff = new Date(now.getTime() - 72*60*60*1000);
            const pad = v => String(v).padStart(2,'0');
            const dstr = d => `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            const j = await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(cutoff)}&dateTo=${dstr(now)}`);
            const rows = (j.matches||[]).map(m => ({
              home: norm(m.homeTeam?.shortName || m.homeTeam?.name || m.homeTeam?.tla),
              away: norm(m.awayTeam?.shortName || m.awayTeam?.name || m.awayTeam?.tla),
              sh:   m.score?.fullTime?.home ?? m.score?.halfTime?.home ?? null,
              sa:   m.score?.fullTime?.away ?? m.score?.halfTime?.away ?? null,
              status: /FINISHED|IN_PLAY|PAUSED/.test(m.status) ? (m.status==='FINISHED'?'post':'in') : 'pre',
              start: m.utcDate || null
            }));
            const latest = new Map();
            for (const r of rows) {
              const key = `${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const prev = latest.get(key);
              if (!prev || rank(r.status) > rank(prev.status)) latest.set(key, r);
            }
            const filtered = Array.from(latest.values()).filter(r => {
              if (!r.start) return false;
              const dt = new Date(r.start);
              return dt >= cutoff && dt <= now;
            }).sort((a,b)=> String(a.start).localeCompare(String(b.start)));
            const results = filtered.filter(r => r.status!=='pre')
              .map(r => `${r.home} ${r.sh ?? '–'}–${r.sa ?? '–'} ${r.away}`);
            return { results_raw: filtered, results_str: results };
          }

          async function fetchUpcoming24h(){
            const now = new Date();
            const end = new Date(now.getTime() + 24*60*60*1000);
            const pad = v => String(v).padStart(2,'0');
            const dstr = d => `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            const j = await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(now)}&dateTo=${dstr(end)}`);
            const rows = (j.matches||[]).map(m => ({
              home: norm(m.homeTeam?.shortName || m.homeTeam?.name || m.homeTeam?.tla),
              away: norm(m.awayTeam?.shortName || m.awayTeam?.name || m.awayTeam?.tla),
              start: m.utcDate || null,
              status: /FINISHED|IN_PLAY|PAUSED/.test(m.status) ? (m.status==='FINISHED'?'post':'in') : 'pre'
            }));
            const seen = new Map(); // Perché: evitare duplicati rari
            for (const r of rows) {
              const key = `${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const prev = seen.get(key);
              if (!prev || (r.start && prev.start && r.start < prev.start)) seen.set(key, r);
            }
            const windowed = Array.from(seen.values()).filter(r => {
              if (!r.start) return false;
              const dt = new Date(r.start);
              return dt >= now && dt <= end && r.status === 'pre';
            }).sort((a,b)=> String(a.start).localeCompare(String(b.start)));

            const todayYMD  = ymdTZ(now, TZ);
            const tomorrowY = ymdTZ(end, TZ); // può coincidere con today se entro 24h prima di mezzanotte?
            const upcoming_str = windowed.map(r => {
              const d = new Date(r.start);
              const lab = (ymdTZ(d, TZ)===todayYMD) ? 'oggi' : (ymdTZ(d, TZ)===tomorrowY ? 'domani' : ymdTZ(d, TZ));
              return `${lab} ${hmTZ(d, TZ)} ${r.home} – ${r.away}`;
            });

            return { upcoming_raw: windowed, upcoming_str };
          }

          (async () => {
            const current = await readCurrent();
            const st   = await fetchStandings();
            const mx72 = await fetchMatches3Days();
            const up24 = await fetchUpcoming24h();

            const payload = {
              ...current,
              teams:    st.teams,
              pos_real: st.pos_real,
              played:   st.played,
              points:   st.points,
              results_raw: mx72.results_raw,
              results_str: mx72.results_str,
              upcoming_raw: up24.upcoming_raw,
              upcoming_str: up24.upcoming_str,
              capo_manual: current.capo_manual || [],
              goals_manual: current.goals_manual || null,
              capo_actual: current.capo_actual || current.capo_manual || [],
              goals: current.goals || current.goals_manual || null,
              synced_at: new Date().toISOString(),
              _sources: {
                provider: 'football-data.org',
                standings: 'football-data_standings',
                results: 'football-data_matches',
                upcoming: 'football-data_matches_next24h',
                scorers: 'manual'
              }
            };

            await writeGist(payload);
            console.log('✅ Gist updated (72h results + next24h fixtures, manual scorers)');
          })().catch(e => { console.error('❌', e.message||e); process.exit(1); });
          NODE
