

name: Update Gist (Serie A) — 72h results + next24h fixtures (merged)

on:
  schedule:
    - cron: "0 16-23 * * 5,6,1"  # Ven/Sab/Lun: 18–23 locali
    - cron: "30 10-22 * * 0"     # Dom: 12:30–23:30 locali (alle :30)
    - cron: "0 22-23 * * 0"      # Extra per 00:00 locali post-Dom
  workflow_dispatch:
    inputs:
      force:
        description: "Esegui subito (ignora guard Europe/Rome)"
        required: false
        default: "false"

permissions: {}
concurrency:
  group: update-serie-a-gist
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 6
    env:
      TZ: Europe/Rome
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check secrets
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "❌ Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "❌ Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "❌ Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "::add-mask::$GIST_TOKEN"
          echo "::add-mask::$FD_TOKEN"
          echo "✅ Secrets OK"

      - name: Build & push Gist (72h results + next24h fixtures → merged)
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE:  Classifica.json
          FORCE_RUN:  ${{ github.event.inputs.force }}
        run: |
          node - <<'NODE'
          const FD='https://api.football-data.org/v4', COMP='SA', TZ='Europe/Rome';
          const HEAD_FD={'X-Auth-Token':process.env.FD_TOKEN,'Accept':'application/json','User-Agent':'fantacena-updater'};
          // Per Gist è ok lo schema "token"
          const HEAD_GH={'authorization':`token ${process.env.GIST_TOKEN}`,'accept':'application/vnd.github+json','user-agent':'seriea-fd-only'};

          const sleep=ms=>new Promise(r=>setTimeout(r,ms));
          async function fetchRetry(u,opt={}, {tries=5,base=400}={}){
            for(let i=0;;i++){
              const r=await fetch(u,opt);
              if(r.ok) return r;
              if(![429,500,502,503,504].includes(r.status) || i>=tries-1){
                const t=await r.text().catch(()=> ''); throw new Error(`${opt.method||'GET'} ${r.status} ${u} ${t}`);
              }
              await sleep(Math.round(base*Math.pow(2,i)));
            }
          }
          async function httpFD(u){ const r=await fetchRetry(u,{headers:HEAD_FD}); return r.json(); }
          async function gh(u,opt={}){ return fetchRetry(u,{...opt,headers:{...HEAD_GH,...(opt.headers||{})}}); }

          (function guard(){
            const force=String(process.env.FORCE_RUN||'false').toLowerCase()==='true';
            if(force){ console.log('⚠️ FORCE_RUN=true'); return; }
            const now=new Date();
            const fmt=ops=>new Intl.DateTimeFormat('en-GB',{timeZone:TZ,...ops});
            const wd=fmt({weekday:'short'}).format(now);
            const hr=+fmt({hour:'2-digit',hour12:false}).format(now);
            const min=+fmt({minute:'2-digit'}).format(now);
            const inRange=(a,b)=>hr>=a&&hr<=b, at=(h,m)=>hr===h&&min===m;
            const isFSM_hours    = (['Fri','Sat','Mon'].includes(wd) && min===0 && inRange(18,23));
            const isFSM_midnight = ((wd==='Sat'||wd==='Sun'||wd==='Tue') && at(0,0));
            const isSun30        = (wd==='Sun' && min===30 && inRange(12,23));
            const isSunMid       = (wd==='Mon' && at(0,0));
            const allowed = isFSM_hours || isFSM_midnight || isSun30 || isSunMid;
            if(!allowed){
              console.log(`⏭️ Outside window ${TZ}: ${wd} ${String(hr).padStart(2,'0')}:${String(min).padStart(2,'0')}`);
              process.exit(0);
            }
          })();

          async function readCurrent(){
            const j=await (await gh(`https://api.github.com/gists/${process.env.GIST_ID}`)).json();
            const f=j.files?.[process.env.GIST_FILE||'Classifica.json'];
            try{ return f&&f.content?JSON.parse(f.content):{}; }catch{ return {}; }
          }
          async function writeGist(payload){
            const body={files:{[process.env.GIST_FILE||'Classifica.json']:{content:JSON.stringify(payload,null,2)}}};
            await gh(`https://api.github.com/gists/${process.env.GIST_ID}`,{method:'PATCH',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
          }

          const norm=s=>String(s||'').replace(/\s+/g,' ').trim();
          const rank=s=>s==='in'?3:s==='post'?2:s==='pre'?1:0;

          async function fetchStandings(){
            const j=await httpFD(`${FD}/competitions/${COMP}/standings`);
            const t=j.standings?.find(s=>/TOTAL/i.test(s.type))?.table||[];
            return {
              teams:   t.map(r=>norm(r.team?.shortName||r.team?.name||r.team?.tla)),
              pos_real:t.map((_,i)=>i+1),
              played:  t.map(r=>r.playedGames ?? null),
              points:  t.map(r=>r.points ?? null)
            };
          }

          async function fetchMatches3Days(){
            const now=new Date(), cutoff=new Date(now.getTime()-72*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            const j=await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(cutoff)}&dateTo=${dstr(now)}`);
            const rows=(j.matches||[]).map(m=>({
              home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
              away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
              sh:m.score?.fullTime?.home ?? m.score?.halfTime?.home ?? null,
              sa:m.score?.fullTime?.away ?? m.score?.halfTime?.away ?? null,
              status:/FINISHED|IN_PLAY|PAUSED/.test(m.status)?(m.status==='FINISHED'?'post':'in'):'pre',
              start:m.utcDate||null
            }));
            const latest=new Map();
            for(const r of rows){
              const k=`${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const p=latest.get(k); if(!p || rank(r.status)>rank(p.status)) latest.set(k,r);
            }
            return Array.from(latest.values()).filter(r=>{
              if(!r.start) return false; const dt=new Date(r.start);
              return dt>=cutoff && dt<=now;
            }).sort((a,b)=>String(a.start).localeCompare(String(b.start)));
          }

          // Prossime 24h, solo future (pre), esclusi POSTPONED/CANCELED/SUSPENDED
          async function fetchUpcoming24hStrict(){
            const now=new Date(), end=new Date(now.getTime()+24*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            let j=await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED&dateFrom=${dstr(now)}&dateTo=${dstr(end)}`);
            if(!j.matches?.length){ j=await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED`); }
            const BAD=new Set(['POSTPONED','CANCELED','SUSPENDED','AWARDED']);
            const rows=(j.matches||[])
              .filter(m=>!BAD.has(String(m.status||'').toUpperCase()))
              .map(m=>({ home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
                         away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
                         sh:null, sa:null, status:'pre', start:m.utcDate||null }))
              .filter(r=>{ const t=Date.parse(r.start||''); return Number.isFinite(t)&&t>=now.getTime()&&t<=end.getTime(); })
              .sort((a,b)=>String(a.start).localeCompare(String(b.start)));
            const seen=new Set(), out=[];
            for(const r of rows){ const k=`${r.home}|${r.away}|${r.start||""}`; if(!seen.has(k)){ seen.add(k); out.push(r); } }
            return out;
          }

          (async()=>{
            const current=await readCurrent();
            const st=await fetchStandings();
            const past72=await fetchMatches3Days();
            const next24=await fetchUpcoming24hStrict();

            const key=r=>`${r.home}|${r.away}|${r.start||""}`;
            const map=new Map();
            for(const r of [...past72, ...next24]){ if(r && r.home && r.away) map.set(key(r), r); }
            const results_raw=[...map.values()];

            const payload={
              ...current,
              teams:st.teams, pos_real:st.pos_real, played:st.played, points:st.points,
              results_raw,
              upcoming_raw: next24,
              counts:{
                pre: results_raw.filter(r=>r.status==='pre').length,
                in:  results_raw.filter(r=>r.status==='in').length,
                post:results_raw.filter(r=>r.status==='post').length
              },
              synced_at:new Date().toISOString(),
              _sources:{
                provider:'football-data.org',
                standings:'football-data_standings',
                results:'football-data_matches',
                upcoming:'football-data_matches_next24h',
                scorers:'manual'
              }
            };

            await writeGist(payload);
            console.log(`✅ results_raw=${results_raw.length} | pre:${payload.counts.pre} in:${payload.counts.in} post:${payload.counts.post}`);
          })().catch(e=>{ console.error('❌', e.stack || e.message || String(e)); process.exit(1); });
          NODE
