name: Update Gist (Serie A) ‚Äî 72h results + next fixtures (orderable)

on:
  schedule:
    # Venerd√¨ (immutato, in UTC)
    - cron: "*/15 16-23 * * 5"

    # Sabato a partire dalle 15:00 ora di Roma (DST-aware):
    # CEST: Apr‚ÄìOct (UTC+2) ‚Üí 13‚Äì23 UTC == 15:00‚Äì01:45 locali
    - cron: "*/15 13-23 * 4-10 6"
    # CET: Nov‚ÄìMar (UTC+1)  ‚Üí 14‚Äì23 UTC == 15:00‚Äì00:45 locali
    - cron: "*/15 14-23 * 11,12,1,2,3 6"

    # Luned√¨ (immutato, in UTC)
    - cron: "*/15 16-23 * * 1"

    # Domenica (immutato)
    - cron: "30,45 10 * * 0"
    - cron: "0,15,30,45 11-21 * * 0"
    - cron: "0,15,30 22 * * 0"
    - cron: "*/15 23 * * 0"

  workflow_dispatch:
    inputs:
      upcoming_order:
        description: "Ordine partite future: asc = dalla pi√π prossima; desc = dalla pi√π lontana"
        required: false
        default: asc
        type: choice
        options: [asc, desc]

permissions: {}
concurrency:
  group: update-serie-a-gist
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 6
    env:
      TZ: Europe/Rome
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Check secrets
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN: ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "‚ùå Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "‚ùå Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "‚ùå Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "::add-mask::$GIST_TOKEN"
          echo "::add-mask::$FD_TOKEN"
          echo "‚úÖ Secrets OK (GIST_ID=${#GIST_ID} chars)"

      - name: Diagnose tokens & endpoints (clear errors)
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN: ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          node - <<'NODE'
          const TZ='Europe/Rome';
          const now=new Date();
          console.log('‚è±Ô∏è Local:', new Intl.DateTimeFormat('it-IT',{dateStyle:'full',timeStyle:'long',timeZone:TZ}).format(now),'| UTC:', now.toISOString());
          const GIST_ID=process.env.GIST_ID, GH=`https://api.github.com/gists/${GIST_ID}`;
          const HEAD_GH={'authorization':`token ${process.env.GIST_TOKEN}`,'accept':'application/vnd.github+json','user-agent':'seriea-diag'};
          const HEAD_FD={'X-Auth-Token':process.env.FD_TOKEN,'Accept':'application/json','User-Agent':'fd-diag'};
          async function probe(url,opt){ const r=await fetch(url,opt).catch(e=>({ok:false,status:0,text:async()=>String(e)})); const t=await r.text(); console.log(`‚Üí ${opt?.method||'GET'} ${url} :: ${r.status} ok=${r.ok}`); if(!r.ok) throw new Error(`${r.status} ${url} :: ${t.slice(0,300).replace(/\s+/g,' ')}`); }
          (async()=>{ await probe(GH,{headers:HEAD_GH}); await probe('https://api.football-data.org/v4/competitions/SA',{headers:HEAD_FD}); })().catch(e=>{ console.error('‚ùå DIAG:', e.message); process.exit(1); });
          NODE

      - name: Build & push Gist (72h results + next fixtures ‚Üí definitive)
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN: ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE: Classifica.json
          UPCOMING_ORDER: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.upcoming_order || vars.UPCOMING_ORDER || 'asc' }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_RUN_ATTEMPT: ${{ github.run_attempt }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_WORKFLOW: ${{ github.workflow }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          node - <<'NODE'
          const FD = "https://api.football-data.org/v4";
          const COMP = "SA";
          const TZ = "Europe/Rome";

          const HEAD_FD = {
            "X-Auth-Token": process.env.FD_TOKEN,
            Accept: "application/json",
            "User-Agent": "fantacena-updater",
          };

          const HEAD_GH = {
            authorization: `token ${process.env.GIST_TOKEN}`,
            accept: "application/vnd.github+json",
            "user-agent": "seriea-fd-only",
          };

          const fmtLocal = new Intl.DateTimeFormat("it-IT", {
            dateStyle: "full",
            timeStyle: "long",
            timeZone: TZ,
          });
          console.log("‚è±Ô∏è Local:", fmtLocal.format(new Date()), "| UTC:", new Date().toISOString());

          const ORDER =
            String(process.env.UPCOMING_ORDER || "asc").toLowerCase() === "desc" ? "desc" : "asc";

          const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

          async function fetchRetry(url, opt = {}, { tries = 6, base = 400 } = {}) {
            for (let i = 0; ; i++) {
              const r = await fetch(url, opt).catch((e) => {
                throw new Error(`${opt.method || "GET"} fetch-failed ${url} :: ${e.message || e}`);
              });
              if (r.ok) return r;

              if (![429, 500, 502, 503, 504].includes(r.status) || i >= tries - 1) {
                const t = await r.text().catch(() => "");
                throw new Error(
                  `${opt.method || "GET"} ${r.status} ${url} ${t.slice(0, 300).replace(/\s+/g, " ")}`
                );
              }

              if (r.status === 429) {
                const resetSec =
                  Number.parseInt(r.headers.get("retry-after") || "", 10) ||
                  Number.parseInt(r.headers.get("x-requestcounter-reset") || "", 10) ||
                  0;
                const waitMs = resetSec > 0 ? (resetSec + 1) * 1000 : Math.round(base * Math.pow(2, i));
                console.log(`‚è≥ 429 rate-limit: waitMs=${waitMs}`);
                await sleep(waitMs);
                continue;
              }

              await sleep(Math.round(base * Math.pow(2, i)));
            }
          }

          async function httpFD(url) {
            const r = await fetchRetry(url, { headers: HEAD_FD });
            return r.json();
          }

          async function gh(url, opt = {}) {
            return fetchRetry(url, { ...opt, headers: { ...HEAD_GH, ...(opt.headers || {}) } });
          }

          async function readCurrent() {
            const r = await gh(`https://api.github.com/gists/${process.env.GIST_ID}`);
            const j = await r.json();
            const f = j.files?.[process.env.GIST_FILE || "Classifica.json"];
            try {
              return f && f.content ? JSON.parse(f.content) : {};
            } catch {
              return {};
            }
          }

          async function writeGist(payload) {
            const body = {
              files: {
                [process.env.GIST_FILE || "Classifica.json"]: {
                  content: JSON.stringify(payload, null, 2),
                },
              },
            };
            const url = `https://api.github.com/gists/${process.env.GIST_ID}`;
            const r = await gh(url, {
              method: "PATCH",
              headers: { "content-type": "application/json" },
              body: JSON.stringify(body),
            });
            if (!r.ok) {
              const txt = await r.text().catch(() => "");
              throw new Error(`PATCH ${r.status} ${url} ${txt.slice(0, 300).replace(/\s+/g, " ")}`);
            }
          }

          const norm = (s) => String(s || "").replace(/\s+/g, " ").trim();
          const ts = (x) => {
            const t = Date.parse(x || "");
            return Number.isFinite(t) ? t : 0;
          };

          const BAD_FD = new Set(["POSTPONED", "CANCELED", "CANCELLED", "SUSPENDED"]);

          function statusBucket(fdStatus) {
            const s = String(fdStatus || "").toUpperCase();
            if (s === "FINISHED" || s === "AWARDED") return "post";
            if (["IN_PLAY", "PAUSED", "EXTRA_TIME", "PENALTY_SHOOTOUT", "LIVE"].includes(s)) return "in";
            return "pre";
          }

          function bucketRank(b) {
            return b === "post" ? 3 : b === "in" ? 2 : 1;
          }

          function hasScore(r) {
            return Number.isFinite(r?.sh) && Number.isFinite(r?.sa);
          }

          function pickBetter(a, b) {
            if (!a) return b;
            if (!b) return a;

            const ra = bucketRank(a.status);
            const rb = bucketRank(b.status);
            if (ra !== rb) return rb > ra ? b : a;

            const ua = ts(a.lastUpdated);
            const ub = ts(b.lastUpdated);
            if (ua !== ub) return ub > ua ? b : a;

            if (hasScore(a) !== hasScore(b)) return hasScore(b) ? b : a;

            const sa = ts(a.start);
            const sb = ts(b.start);
            if (sa !== sb) return sb > sa ? b : a;

            return b;
          }

          function mapMatch(m) {
            const fdStatus = String(m.status || "").toUpperCase();
            const bucket = statusBucket(fdStatus);

            const score = m.score?.fullTime ?? m.score?.regularTime ?? m.score?.halfTime ?? {};
            const sh = score.home ?? null;
            const sa = score.away ?? null;

            return {
              id: m.id ?? null,
              home: norm(m.homeTeam?.shortName || m.homeTeam?.name || m.homeTeam?.tla),
              away: norm(m.awayTeam?.shortName || m.awayTeam?.name || m.awayTeam?.tla),
              sh,
              sa,
              status: bucket,
              start: m.utcDate || null,
              lastUpdated: m.lastUpdated || null,
              _fd_status: fdStatus,
            };
          }

          function keyMatch(r) {
            return r.id ? `id:${r.id}` : `k:${r.home}|${r.away}|${r.start || ""}`;
          }

          function pad2(v) {
            return String(v).padStart(2, "0");
          }
          function dstrUTC(d) {
            return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())}`;
          }

          async function fetchStandings() {
            const j = await httpFD(`${FD}/competitions/${COMP}/standings`);
            const t = j.standings?.find((s) => /TOTAL/i.test(s.type))?.table || [];
            return {
              teams: t.map((r) => norm(r.team?.shortName || r.team?.name || r.team?.tla)),
              pos_real: t.map((_, i) => i + 1),
              played: t.map((r) => r.playedGames ?? null),
              points: t.map((r) => r.points ?? null),
            };
          }

          async function fetchMatchesPast72h() {
            const now = new Date();
            const cutoff = new Date(now.getTime() - 72 * 60 * 60 * 1000);
            const df = dstrUTC(cutoff);
            const dt = dstrUTC(now);

            const all = await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${df}&dateTo=${dt}`);
            const played = await httpFD(
              `${FD}/competitions/${COMP}/matches?dateFrom=${df}&dateTo=${dt}&status=FINISHED,IN_PLAY,PAUSED,EXTRA_TIME,PENALTY_SHOOTOUT`
            );

            const map = new Map();

            for (const src of [all, played]) {
              for (const m of src.matches || []) {
                const r = mapMatch(m);
                if (!r.start) continue;

                const startTs = ts(r.start);
                if (!startTs) continue;
                if (startTs < cutoff.getTime() || startTs > now.getTime()) continue;

                if (BAD_FD.has(r._fd_status)) continue;

                const k = keyMatch(r);
                map.set(k, pickBetter(map.get(k), r));
              }
            }

            return Array.from(map.values()).sort((a, b) => ts(a.start) - ts(b.start));
          }

          const cmpUpcoming = (a, b) => {
            const ta = ts(a.start);
            const tb = ts(b.start);
            if (ta !== tb) return ta - tb;
            return `${a.home}|${a.away}`.toLowerCase().localeCompare(`${b.home}|${b.away}`.toLowerCase());
          };

          async function fetchUpcomingNext5Days() {
            const now = new Date();
            const end = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000);
            const df = dstrUTC(now);
            const dt = dstrUTC(end);

            let j = await httpFD(
              `${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED&dateFrom=${df}&dateTo=${dt}`
            );
            if (!j.matches?.length) {
              j = await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED`);
            }

            let rows = (j.matches || [])
              .map(mapMatch)
              .filter((r) => {
                if (!r.start) return false;
                if (BAD_FD.has(r._fd_status)) return false;
                const t = ts(r.start);
                return t >= now.getTime() && t <= end.getTime();
              })
              .sort(cmpUpcoming);

            if (ORDER === "desc") rows = rows.reverse();

            const seen = new Set();
            const out = [];
            for (const r of rows) {
              const k = keyMatch(r);
              if (seen.has(k)) continue;
              seen.add(k);
              out.push(r);
            }
            return out;
          }

          (async () => {
            const current = await readCurrent();
            const st = await fetchStandings();
            const past72 = await fetchMatchesPast72h();
            const upcoming = await fetchUpcomingNext5Days();

            const merged = new Map();
            for (const r of [...past72, ...upcoming]) {
              if (!r || !r.home || !r.away) continue;
              const k = keyMatch(r);
              merged.set(k, pickBetter(merged.get(k), r));
            }
            const results_raw = Array.from(merged.values()).sort((a, b) => ts(a.start) - ts(b.start));

            const now = new Date();
            const payload = {
              ...current,
              teams: st.teams,
              pos_real: st.pos_real,
              played: st.played,
              points: st.points,

              results_raw,
              upcoming_raw: upcoming,

              counts: {
                pre: results_raw.filter((r) => r.status === "pre").length,
                in: results_raw.filter((r) => r.status === "in").length,
                post: results_raw.filter((r) => r.status === "post").length,
              },

              synced_at: now.toISOString(),
              _meta: {
                timezone: TZ,
                order_upcoming: ORDER,
                now_local: new Intl.DateTimeFormat("sv-SE", {
                  timeZone: TZ,
                  hour12: false,
                  dateStyle: "short",
                  timeStyle: "medium",
                }).format(now),
                now_utc: now.toISOString(),
                run_id: process.env.GITHUB_RUN_ID || null,
                run_attempt: process.env.GITHUB_RUN_ATTEMPT || null,
                repo: process.env.GITHUB_REPOSITORY || null,
                workflow: process.env.GITHUB_WORKFLOW || null,
                sha: process.env.GITHUB_SHA || null,
              },
              _sources: {
                provider: "football-data.org",
                standings: "football-data_standings",
                results: "football-data_matches_past72h",
                upcoming: `football-data_matches_next_5d_${ORDER}`,
                scorers: "manual",
              },
            };

            console.log(
              `üì¶ past72=${past72.length} upcoming=${upcoming.length} merged=${results_raw.length} | counts=`,
              payload.counts
            );

            await writeGist(payload);
            console.log("‚úÖ Gist updated.");
          })().catch((e) => {
            console.error("‚ùå ERROR:", e?.message || e);
            process.exit(1);
          });
          NODE
