
name: Update Gist (Serie A) — 72h results + next24h fixtures (merged)

on:
  schedule:
    # ⚠️ GitHub cron è in UTC
    # Ven/Sab/Lun: ogni 15' tra le 16–23 UTC
    - cron: "*/15 16-23 * * 5,6,1"
    # Dom: 10:30–22:30 UTC ogni 15' (senza duplicare)
    - cron: "30,45 10 * * 0"          # 10:30, 10:45
    - cron: "0,15,30,45 11-21 * * 0"  # 11:00 → 21:45
    - cron: "0,15,30 22 * * 0"        # 22:00, 22:15, 22:30
    # Extra (mezzanotte locale in CET): 23:00–23:45 UTC, ogni 15'
    - cron: "*/15 23 * * 0"
  workflow_dispatch: {}

permissions: {}
concurrency:
  group: update-serie-a-gist
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 6
    env:
      TZ: Europe/Rome
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check secrets
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "❌ Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "❌ Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "❌ Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "::add-mask::$GIST_TOKEN"
          echo "::add-mask::$FD_TOKEN"
          echo "✅ Secrets OK"

      - name: Build & push Gist (72h results + next24h fixtures → merged)
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE:  Classifica.json
          GITHUB_RUN_ID:       ${{ github.run_id }}
          GITHUB_RUN_ATTEMPT:  ${{ github.run_attempt }}
          GITHUB_REPOSITORY:   ${{ github.repository }}
          GITHUB_WORKFLOW:     ${{ github.workflow }}
          GITHUB_SHA:          ${{ github.sha }}
        run: |
          node - <<'NODE'
          // file: .github/workflows/update-serie-a-gist.js (embedded)
          const FD='https://api.football-data.org/v4', COMP='SA', TZ='Europe/Rome';
          const HEAD_FD={'X-Auth-Token':process.env.FD_TOKEN,'Accept':'application/json','User-Agent':'fantacena-updater'};
          const HEAD_GH={'authorization':`token ${process.env.GIST_TOKEN}`,'accept':'application/vnd.github+json','user-agent':'seriea-fd-only'};

          const fmtLocal = new Intl.DateTimeFormat('it-IT',{dateStyle:'full', timeStyle:'long', timeZone:TZ});
          console.log('⏱️ Ora locale:', fmtLocal.format(new Date()), '| UTC:', new Date().toISOString());

          const sleep=ms=>new Promise(r=>setTimeout(r,ms));
          async function fetchRetry(u,opt={}, {tries=5,base=400}={}){
            for(let i=0;;i++){
              const r=await fetch(u,opt);
              if(r.ok) return r;
              if(![429,500,502,503,504].includes(r.status) || i>=tries-1){
                const t=await r.text().catch(()=> ''); throw new Error(`${opt.method||'GET'} ${r.status} ${u} ${t}`);
              }
              await sleep(Math.round(base*Math.pow(2,i)));
            }
          }
          async function httpFD(u){ const r=await fetchRetry(u,{headers:HEAD_FD}); return r.json(); }
          async function gh(u,opt={}){ return fetchRetry(u,{...opt,headers:{...HEAD_GH,...(opt.headers||{})}}); }

          // ✅ Nessun guard(): ci affidiamo solo al cron

          async function readCurrent(){
            const j=await (await gh(`https://api.github.com/gists/${process.env.GIST_ID}`)).json();
            const f=j.files?.[process.env.GIST_FILE||'Classifica.json'];
            try{ return f&&f.content?JSON.parse(f.content):{}; }catch{ return {}; }
          }
          async function writeGist(payload){
            const body={files:{[process.env.GIST_FILE||'Classifica.json']:{content:JSON.stringify(payload,null,2)}}};
            await gh(`https://api.github.com/gists/${process.env.GIST_ID]}`,{method:'PATCH',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
          }

          const norm=s=>String(s||'').replace(/\s+/g,' ').trim();
          const rank=s=>s==='in'?3:s==='post'?2:s==='pre'?1:0;

          async function fetchStandings(){
            const j=await httpFD(`${FD}/competitions/${COMP}/standings`);
            const t=j.standings?.find(s=>/TOTAL/i.test(s.type))?.table||[];
            return {
              teams:   t.map(r=>norm(r.team?.shortName||r.team?.name||r.team?.tla)),
              pos_real:t.map((_,i)=>i+1),
              played:  t.map(r=>r.playedGames ?? null),
              points:  t.map(r=>r.points ?? null)
            };
          }

          async function fetchMatches3Days(){
            const now=new Date(), cutoff=new Date(now.getTime()-72*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            const j=await httpFD(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(cutoff)}&dateTo=${dstr(now)}`);
            const rows=(j.matches||[]).map(m=>({
              home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
              away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
              sh:m.score?.fullTime?.home ?? m.score?.halfTime?.home ?? null,
              sa:m.score?.fullTime?.away ?? m.score?.halfTime?.away ?? null,
              status:/FINISHED|IN_PLAY|PAUSED/.test(m.status)?(m.status==='FINISHED'?'post':'in'):'pre',
              start:m.utcDate||null
            }));
            const latest=new Map();
            for(const r of rows){
              const k=`${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const p=latest.get(k); if(!p || rank(r.status)>rank(p.status)) latest.set(k,r);
            }
            return Array.from(latest.values()).filter(r=>{
              if(!r.start) return false; const dt=new Date(r.start);
              return dt>=cutoff && dt<=now;
            }).sort((a,b)=>String(a.start).localeCompare(String(b.start)));
          }

          async function fetchUpcoming24hStrict(){
            const now=new Date(), end=new Date(now.getTime()+24*60*60*1000);
            const pad=v=>String(v).padStart(2,'0'), dstr=d=>`${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
            let j=await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED&dateFrom=${dstr(now)}&dateTo=${dstr(end)}`);
            if(!j.matches?.length){ j=await httpFD(`${FD}/competitions/${COMP}/matches?status=SCHEDULED,TIMED`); }
            const BAD=new Set(['POSTPONED','CANCELED','SUSPENDED','AWARDED']);
            const rows=(j.matches||[])
              .filter(m=>!BAD.has(String(m.status||'').toUpperCase()))
              .map(m=>({ home:norm(m.homeTeam?.shortName||m.homeTeam?.name||m.homeTeam?.tla),
                         away:norm(m.awayTeam?.shortName||m.awayTeam?.name||m.awayTeam?.tla),
                         sh:null, sa:null, status:'pre', start:m.utcDate||null }))
              .filter(r=>{ const t=Date.parse(r.start||''); return Number.isFinite(t)&&t>=now.getTime()&&t<=end.getTime(); })
              .sort((a,b)=>String(a.start).localeCompare(String(b.start)));
            const seen=new Set(), out=[];
            for(const r of rows){ const k=`${r.home}|${r.away}|${r.start||""}`; if(!seen.has(k)){ seen.add(k); out.push(r); } }
            return out;
          }

          (async()=>{
            const current=await readCurrent();
            const st=await fetchStandings();
            const past72=await fetchMatches3Days();
            const next24=await fetchUpcoming24hStrict();

            const key=r=>`${r.home}|${r.away}|${r.start||""}`;
            const map=new Map();
            for(const r of [...past72, ...next24]){ if(r && r.home && r.away) map.set(key(r), r); }
            const results_raw=[...map.values()];

            const now = new Date();
            const payload={
              ...current,
              teams:st.teams, pos_real:st.pos_real, played:st.played, points:st.points,
              results_raw,
              upcoming_raw: next24,
              counts:{
                pre: results_raw.filter(r=>r.status==='pre').length,
                in:  results_raw.filter(r=>r.status==='in').length,
                post:results_raw.filter(r=>r.status==='post').length
              },
              synced_at: now.toISOString(),
              _meta:{
                timezone: TZ,
                now_local: new Intl.DateTimeFormat('sv-SE',{timeZone:TZ, hour12:false, dateStyle:'short', timeStyle:'medium'}).format(now),
                now_utc: now.toISOString(),
                run_id: process.env.GITHUB_RUN_ID || null,
                run_attempt: process.env.GITHUB_RUN_ATTEMPT || null,
                repo: process.env.GITHUB_REPOSITORY || null,
                workflow: process.env.GITHUB_WORKFLOW || null,
                sha: process.env.GITHUB_SHA || null
              },
              _sources:{
                provider:'football-data.org',
                standings:'football-data_standings',
                results:'football-data_matches',
                upcoming:'football-data_matches_next24h',
                scorers:'manual'
              }
            };

            await writeGist(payload);
            console.log(`✅ Gist aggiornato | results_raw=${results_raw.length} | pre:${payload.counts.pre} in:${payload.counts.in} post:${payload.counts.post}`);
          })().catch(e=>{ console.error('❌', e.stack || e.message || String(e)); process.exit(1); });
          NODE
