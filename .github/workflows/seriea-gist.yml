name: Update Gist (Serie A) — clean dedup (manual scorers, 3 days only)

on:
  schedule:
    - cron: "0 21 * * 5,6,0,1"
    - cron: "0 22 * * 5,6,0,1"
  workflow_dispatch:
    inputs:
      force:
        description: "Esegui subito (ignora guard: 23:00 Europe/Rome)"
        required: false
        default: "false"

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with: { node-version: '20' }

      - name: Check secrets
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
        run: |
          test -n "$GIST_ID"    || { echo "❌ Missing GIST_ID"; exit 1; }
          test -n "$GIST_TOKEN" || { echo "❌ Missing GIST_TOKEN"; exit 1; }
          test -n "$FD_TOKEN"   || { echo "❌ Missing FOOTBALL_DATA_TOKEN"; exit 1; }
          echo "✅ Secrets OK"

      - name: Build & push Gist (dedup, clean, 3 days only)
        env:
          GIST_ID:    ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          FD_TOKEN:   ${{ secrets.FOOTBALL_DATA_TOKEN }}
          GIST_FILE:  Classifica.json
          FORCE_RUN:  ${{ github.event.inputs.force }}
        run: |
          node - <<'NODE'
          const FD = 'https://api.football-data.org/v4';
          const COMP = 'SA'; // Serie A
          const HEAD = { 'X-Auth-Token': process.env.FD_TOKEN, 'User-Agent':'fantacena-updater' };

          // Guard 23:00 Europe/Rome (skippabile)
          (function(){
            const force = String(process.env.FORCE_RUN||'false').toLowerCase()==='true';
            if (force) return console.log('⚠️ FORCE_RUN=true');
            const hr = new Intl.DateTimeFormat('it-IT',{timeZone:'Europe/Rome',hour:'2-digit',hour12:false}).format(new Date());
            if (hr !== '23') { console.log('⏭️ Not 23:00 Europe/Rome (',hr,')'); process.exit(0); }
          })();

          async function http(u){ const r=await fetch(u,{headers:HEAD}); if(!r.ok) throw new Error(`${r.status} ${u}`); return r.json(); }
          async function gh(url,opt={}) {
            const r = await fetch(url,{...opt,headers:{'authorization':`token ${process.env.GIST_TOKEN}`,'accept':'application/vnd.github+json','user-agent':'seriea-fd-only',...(opt.headers||{})}});
            if (!r.ok) throw new Error(`${opt.method||'GET'} ${url} -> ${r.status}`);
            return r;
          }
          async function readCurrent(){
            const j = await (await gh(`https://api.github.com/gists/${process.env.GIST_ID}`)).json();
            const f = j.files[process.env.GIST_FILE||'Classifica.json']; try { return f && f.content ? JSON.parse(f.content) : {}; } catch { return {}; }
          }
          async function writeGist(payload){
            const body = { files: { [process.env.GIST_FILE||'Classifica.json']: { content: JSON.stringify(payload,null,2) } } };
            await gh(`https://api.github.com/gists/${process.env.GIST_ID}`, { method:'PATCH', headers:{'content-type':'application/json'}, body:JSON.stringify(body) });
          }

          function norm(name){ return String(name||'').replace(/\s+/g,' ').trim(); }

          async function fetchStandings(){
            const j = await http(`${FD}/competitions/${COMP}/standings`);
            const standings = j.standings?.find(s=>/TOTAL/i.test(s.type))?.table || [];
            const teams   = standings.map(r => norm(r.team?.shortName || r.team?.name || r.team?.tla));
            const pos     = standings.map((_,i)=>i+1);
            const played  = standings.map(r => r.playedGames ?? null);
            const points  = standings.map(r => r.points ?? null);
            return { teams, pos_real:pos, played, points };
          }

          // ✅ Fetch ultimi 3 giorni + dedup + no vecchie partite
          async function fetchMatches3Days(current={}){
            const today = new Date();
            const from = new Date(today);
            from.setUTCDate(from.getUTCDate() - 3);

            const pad = v => String(v).padStart(2, '0');
            const dstr = d => `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())}`;

            const j = await http(`${FD}/competitions/${COMP}/matches?dateFrom=${dstr(from)}&dateTo=${dstr(today)}`);

            const rows = (j.matches || []).map(m => ({
              home: norm(m.homeTeam?.shortName || m.homeTeam?.name || m.homeTeam?.tla),
              away: norm(m.awayTeam?.shortName || m.awayTeam?.name || m.awayTeam?.tla),
              sh:   m.score?.fullTime?.home ?? m.score?.halfTime?.home ?? null,
              sa:   m.score?.fullTime?.away ?? m.score?.halfTime?.away ?? null,
              status: /FINISHED|IN_PLAY|PAUSED/.test(m.status) ? (m.status === 'FINISHED' ? 'post' : 'in') : 'pre',
              start: m.utcDate || null
            }));

            const combined = [ ...rows ];
            const latest = new Map();
            const rank = s => s === 'in' ? 3 : s === 'post' ? 2 : s === 'pre' ? 1 : 0;

            for (const r of combined) {
              const key = `${r.home.toLowerCase()}|${r.away.toLowerCase()}`;
              const prev = latest.get(key);
              if (!prev || rank(r.status) > rank(prev.status)) latest.set(key, r);
            }

            const filtered = Array.from(latest.values()).filter(r => {
              if (!r.start) return false;
              const s = new Date(r.start);
              return s >= from && s <= today;
            });

            const results = filtered
              .filter(r => r.status !== 'pre')
              .map(r => `${r.home} ${r.sh ?? '–'}–${r.sa ?? '–'} ${r.away}`);

            return { results_raw: filtered.sort((a,b)=>String(a.start).localeCompare(String(b.start))), results_str: results };
          }

          (async () => {
            const current = await readCurrent();
            const st  = await fetchStandings();
            const mx  = await fetchMatches3Days(current);

            const payload = {
              ...current,
              teams: st.teams,
              pos_real: st.pos_real,
              played: st.played,
              points: st.points,
              results_raw: mx.results_raw,
              results_str: mx.results_str,
              capo_manual: current.capo_manual || [],
              goals_manual: current.goals_manual || null,
              capo_actual: current.capo_actual || current.capo_manual || [],
              goals: current.goals || current.goals_manual || null,
              synced_at: new Date().toISOString(),
              _sources: {
                provider: 'football-data.org',
                standings: 'football-data_standings',
                results: 'football-data_matches',
                scorers: 'manual'
              }
            };

            await writeGist(payload);
            console.log('✅ Gist updated (3 days clean dedup)');
          })().catch(e=>{ console.error(e); process.exit(1); });
          NODE
